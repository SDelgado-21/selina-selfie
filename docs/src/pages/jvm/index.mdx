import { Hero } from "@/components/Hero";
import { Selfie } from "@/components/Selfie";
import { NavHeading } from "@/components/NavHeading";

export const showHero = true;

<NavHeading text="literal" />

Sure, you could write your assertions like this.

```java
@Test
public void login() {
  given().redirects().follow(false)
    .post("/confirm/login/erjchFbCXxMlUfFXx3oYiO-Rj6zM7tRGdRV8ziqRn5Jh")
    .then()
    .cookie("login", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiaXNzIjoiZGlmZnBsdWcuY29tIiwiYXVkIjoiZGlmZnBsdWcuY29tIiwiaWF0IjoxNTc3NjY0MDAsImVtYWlsIjoibHVrZS5za3l3YWxrZXJAZGlmZnBsdWcuY29tIiwic2FsZXMiOiJ0cnVlIn0.v7nes7_rTa0NiwTz6OLIAmRZJ-XzzGULRiAPWBiV5iI");
}
```

But isn't this easier to read? And also more complete?

```java
@Test
public void login() {
  expectSelfie(
      given().redirects().follow(false).post("/confirm/login/erjchFbCXxMlUfFXx3oYiO-Rj6zM7tRGdRV8ziqRn5Jh").headers()
    ).toBe("""
      content-type=text/plain
      set-cookie=flash=success=You+are+now+logged+in%21;Path=/;HttpOnly
      set-cookie=loginui="{\"username\":\"testuser@diffplug.com\"}";Path=/;Max-Age=604800;Expires=Wed, 01-Jan-2000 00:00:00 GMT
      set-cookie=login=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiaXNzIjoiZGlmZnBsdWcuY29tIiwiYXVkIjoiZGlmZnBsdWcuY29tIiwiaWF0IjoxNTc3NjY0MDAsImVtYWlsIjoibHVrZS5za3l3YWxrZXJAZGlmZnBsdWcuY29tIiwic2FsZXMiOiJ0cnVlIn0.v7nes7_rTa0NiwTz6OLIAmRZJ-XzzGULRiAPWBiV5iI;Path=/;HttpOnly;Max-Age=604800;Expires=Wed, 01-Jan-2000 00:00:00 GMT
      location=/settings
      content-length=0
      """);
}
```

The only reason we don't test that way already is that it's too tedious to write out that big string literal. Buf if you write this...

```java
@Test
public void login() {
  expectSelfie(
      given().redirects().follow(false).post("/confirm/login/erjchFbCXxMlUfFXx3oYiO-Rj6zM7tRGdRV8ziqRn5Jh").headers()
    ).toBe_TODO()
}
```

... then selfie will rewrite the string literal for you when you run your tests.

It's like a printf directly into your code. And it's not just for strings, it's for any literal.

```java
@Test
public void preventCssBloat() {
  int size = expectSelfie(get("/index.css").length).toBe(5_236);
  if (size > 100_000) {
    Assert.fail("CSS has gotten too big! " + size);
  }
}
```

<NavHeading text="like-a-filesystem" />

Some snapshots are so big that it would be cumbersome to put them inline into your test code. So selfie helps you put them on disk.

```java
@Test public void gzipFavicon() {
    expectSelfie(get("/favicon.ico", ContentEncoding.GZIP)).toMatchDisk();
}
@Test public void orderFlow() {
  expectSelfie(get("/orders")).toMatchDisk("initial");
  postOrder();
  expectSelfie(get("/orders")).toMatchDisk("ordered");
}
```

This will generate a snapshot file like so:

```html
╔═ gzipFavicon ═╗ base64 length 823 bytes
H4sIAAAAAAAA/8pIzcnJVyjPL8pJUQQAlQYXAAAA
╔═ orderFlow/initial ═╗
<html><body>
  <button>Submit order</button>
</body></html>
╔═ orderFlow/ordered ═╗
<html><body>
  <p>Thanks for your business!</p>
  <details>
    <summary>Order information</summary>
    <p>Tracking #ABC123</p>
  </details>
</body></html>
```

Selfie's snapshot files `.ss` are simple to parse, just split them up on `\n╔═`. Escaping rules only come into play if the content you are escaping has lines that start with `╔`,  and you can always use `selfie-lib` as a parser if you want.

You can treat your snapshot files as an output deliverable of your code, and use them as an input to other tooling.

<NavHeading text="lensable" />

A problem with the snapshots we've shown so far is that they are one dimensional. What about headers and cookies? What about the content the user actually sees, without all the markup? What if we could do this? 

```
╔═ orderFlow/initial [md] ═╗
Submit order
╔═ orderFlow/ordered [md] ═╗
Thanks for your business!</p>
```

Well, you can! Every snapshot has a *subject*, which is the main thing you are recording. And that subject can have any number of *facets*, which are named views of the subject from a different lens.

```java
var html = "<html>..."
var snapshot = Snapshot.of(html).plusFacet("md", HtmlToMdParser.parse(html))
expectSelfie(snapshot).toMatchDisk()
```

You can also use facets in combination with disk and inline literal snapshots to make your tests more like a story.

```java
@Test public void orderFlow() {
  expectSelfie(get("/orders")).toMatchDisk("initial")
    .facet("md").toBe("Submit order");
  postOrder();
  expectSelfie(get("/orders")).toMatchDisk("ordered")
    .facet("md").toBe("Thanks for your business!");
}
```

Selfie's faceting is built around [Camera](https://kdoc.selfie.dev/selfie-lib/com.diffplug.selfie/-camera/), [Lens](https://kdoc.selfie.dev/selfie-lib/com.diffplug.selfie/-lens/), and [Snapshot](https://kdoc.selfie.dev/selfie-lib/com.diffplug.selfie/-snapshot/), whose API is roughly:

```java
final class Snapshot {
  final SnapshotValue subject;
  final ImmutableSortedMap<String, SnapshotValue> facets;
}
interface Lens {
  Snapshot transform(Snapshot snapshot);
}
interface Camera<T> {
  Snapshot snapshot(T subject);
  default Camera<T> withLens(Lens lens) {
    // returns a new Camera which applies the given lens to every snapshot
  }
}
```

See the [advanced section](/jvm/advanced) for more details.